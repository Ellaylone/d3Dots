<!DOCTYPE html>
<html>
<meta charset="utf-8">
<body>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script>
//NOTE вспомогательные переменные
var width = 960,
	height = 500,
	radius = 30,
	number =51,
	color = d3.scale.category10().domain(['blue','orange','green','red']),
	nodes = d3.range(number).map(function() {
		var pos = {x:0, y:0, dx:.5, dy:.5, radius:radius};
		calcStartPosition(pos)
		return pos;
	}),
	root = nodes[0];
//NOTE определяем стартовую позицию
function calcStartPosition(pos){
	var borderPos = {xMin: pos.r, xMax: width - pos.r, yMin: pos.r, yMax: height - pos.r};
	pos.x = width * Math.random();
	if(pos.x < borderPos.xMin) pos.x = borderPos.xMin;
	if(pos.x > borderPos.xMax) pos.x = borderPos.xMax;
	pos.y = height * Math.random();
	if(pos.y < borderPos.yMin) pos.y = borderPos.yMin;
	if(pos.y > borderPos.yMax) pos.y = borderPos.yMax;
	pos.dx = Math.random() - .5;
	pos.dy = Math.random() - .5;
}
root.radius = 0;
root.fixed = true;

//NOTE создаем svg по заданным параметрам
var svg = d3.select("body").append("svg:svg")
		.attr("width", width)
		.attr("height", height)
		.style("border", "1px solid black");

//NOTE пихаем в svg точки
var circle = svg.selectAll("circle")
		.data(nodes)
	.enter().append("svg:circle")
	.attr("r", function(d) {return d.radius})
	.style('fill', color('orange'));
circle.each(function(){
  animateColorChange(d3.select(this), 'orange', 'red');
});

// var force = d3.layout.force().charge(function(d,i){return i ? -10 : -10; }).nodes(nodes).size([width, height]);
// var force = d3.layout.force()
//     // .gravity(0.05)
//     .charge(function(d, i) { return i ? 0 : -2000; })
//     .nodes(nodes)
//     .size([width, height]);
// force.start();
// force.on("tick", function(e) {
//   var q = d3.geom.quadtree(nodes),
//       i = 0,
//       n = nodes.length;

//   while (++i < n) q.visit(collide(nodes[i]));

//   svg.selectAll("circle")
//       .attr("cx", function(d) { return d.x; })
//       .attr("cy", function(d) { return d.y; });
// });
// svg.on("mousemove", function() {
//   var p1 = d3.mouse(this);
//   root.px = p1[0];
//   root.py = p1[1];
//   force.resume();
// });

//NOTE вывести счетчик фреймов
var text = svg.append("svg:text")
		.attr("x", 20)
		.attr("y", 20);

//NOTE вспомогательные переменные для таймера
var start = Date.now(),
		frames = 0;

d3.timer(function() {

	//NOTE обновление счетчика
	var now = Date.now(), duration = now - start;
	text.text(~~(++frames * 1000 / duration));
	if (duration >= 1000) frames = 0, start = now;

	//NOTE обновление позиции точки
	circle
			.attr("cx", function(d) { 
					d.x += d.dx; 
					if (d.x > (width - radius)) {
						d.dx = -1 * d.dx;
						d.x = (width - radius);
					} else if (d.x < radius) {
						d.dx = -1 * d.dx;
						d.x = radius;
					}
					return d.x;  
				})
			.attr("cy", function(d) { 
				d.y += d.dy; 
				if (d.y > (height - radius)) {
					d.dy = -1 * d.dy; 
					d.y = (height - radius);
				} else if (d.y < radius) {
					d.dy = -1 * d.dy;
					d.y = radius;
				}
				return d.y; 
			});
      // 
	 var q = d3.geom.quadtree(nodes),
      i = 0,
      n = nodes.length;
    while (++i < n) q.visit(collide(nodes[i]));
});
function animateColorChange(node, from, to){
  node.transition().duration(Math.floor((Math.random() * 2900) + 100)).style('fill', color(to)).each('end', function(){
      animateColorChange(d3.select(this), to, from);
      //   e.transition().duration(100).style('fill', color('orange'));
  })
}
function collide(node) {
  var r = node.radius + 16,
      nx1 = node.x - r,
      nx2 = node.x + r,
      ny1 = node.y - r,
      ny2 = node.y + r;
      console.log(node);
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        l = (l - r) / l * .5;
      var dx = node.dx, dy = node.dy;
      node.dx = quad.point.dx;
      node.dy = quad.point.dy;
      quad.point.dx = dx;
      quad.point.dy = dy;
      // var a = node.x-quad.point.x;
      // var b = node.y-quad.point.y;
      // var p1 = a * b,
      // p2 = a * a,
      // p3 = b * b;
      // var d1 = node.dy * p1 + node.dx * p2 - quad.point.dx * p1 - quad.point.dy * p2,
      // d2 = node.dy * p1 + node.dx * p3 - quad.point.dx * p1 - quad.point.dy * p3;
      // node.dx = node.dx-d1;
      // node.dy = node.hy-d2;
      // quad.point.dx = quad.point.dx+d1;
      // quad.point.dy = quad.point.hy+d2;
        node.x -= x *= l;
        node.y -= y *= l;
        quad.point.x += x;
        quad.point.y += y;
      }
    }
    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
  };
};
</script>
</body>
</html>